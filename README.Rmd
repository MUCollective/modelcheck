---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# VMC: An R package for generating model check visualizations

<!-- badges: start -->
<!-- badges: end -->

`vmc` is a visualization grammar designed to make it easy to generate informative visualizations for model checking. The `vmc` grammar assumes a basic workflow for creating model checks. First, the model predictions or model features need to be extracted as a **distribution** of data from a model object, i.e. data tidying. Then the user must specify an **uncertainty representation** to describe the selected distribution(s). They must also specify the presentation of the observed data. The user can choose among multiple **comparative layouts** to structure their comparison between observed data and model predictions.

## Installation

You can install the development version of vmc from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("MUCollective/vmc")
```

## Usage

### Set up

```{r setup, message = FALSE, warning = FALSE}
library(vmc)
library(ggplot2)
library(dplyr)
library(palmerpenguins)
library(brms)
library(ggdist)
library(tidybayes)
library(cowplot)
library(tidyr)
library(gganimate)

theme_set(theme_tidybayes() + panel_border())
```

### Model

First, we fit a beta regression model to predict the penguins' bill ratio (i.e., bill depth / bill length) based on penguins' flipper length.

```{r}
penguins <- penguins %>%
  drop_na(sex) %>%
  mutate(is_gentoo = species == "Gentoo") %>%
  mutate(bill_ratio = bill_depth_mm / bill_length_mm)
```

```{r}
model_beta <- brm(
  bf(bill_ratio ~ flipper_length_mm,
     phi ~ flipper_length_mm),
  family = Beta(),
  init = "0",
  data = penguins,
  prior = c(prior(normal(0, 1), class = "b"),
            prior(exponential(1), class = "b", dpar = "phi", lb = 0)),
  file = "models/model.rds"
)
```

The results...

```{r}
model_beta
```

### Check on the shape of distrition

You can start model checking by check the shape of the distribution of predicted bill ratio and observed bill ratio. Using `vmc`, you can create a posterior predictive check by only one `mcplot()` (and also using `coord_flip()` to flip the response variable to the x-axis).

```{r}
model_beta %>%
  mcplot() +
  mc_gglayer(coord_flip())
```

You can not only check on the shape of posterior predictive distribution, but also check on other posterior distributions generated by `model_beta` using the `mc_distribution` component. For example, there are two parameter `mu` and `phi` besides the response variable in the beta regression model we are using. Here, we are check on the posterior distribution of `mu`.

```{r}
model_beta %>%
  mcplot() +
  mc_distribution("mu") +
  mc_observation_transformation(mean, group = vars(flipper_length_mm)) +
  mc_gglayer(coord_flip())
```

### Check on the marginal effects

You may find the misalignment between the shape of predictive distribution and observed distribution. You can scrutinize the misalignment further by checking on the marginal effects of the predictor using `mc_condition_on`.

```{r}
model_beta %>%
  mcplot() +
  mc_distribution(ndraws = 1) +
  mc_condition_on(x = vars(flipper_length_mm))
```

To reveal the uncertainty information inside of the model predictions, you can use either HOPs or other uncertainty representations.

`vmc` supports HOPs as a method to group samples (see `vignette("uncertainty-representation")`).

```{r}
model_beta %>%
  mcplot() +
  mc_distribution(ndraws = 50) +
  mc_model_point(group_sample = "hops") +
  mc_condition_on(x = vars(flipper_length_mm))
```

You may find that some of the points of model predictions and observed data are overlapped together, which may cause visual clutter. To fix this problem, you can change to another comparative layout using `mc_layout_*`.

```{r}
model_beta %>%
  mcplot() +
  mc_distribution(ndraws = 50) +
  mc_model_point(group_sample = "hops") +
  mc_condition_on(x = vars(flipper_length_mm)) +
  mc_layout_juxtaposition()
```


Other uncertainty representations are supported by the visual representation components (`mc_model_*` and `mc_obs_*`).

```{r}
model_beta %>%
  mcplot() +
  mc_distribution(ndraws = 1000) +
  mc_model_lineribbon() +
  mc_condition_on(x = vars(flipper_length_mm))
```

### Facet to find the source of multimodal

You may find there seem to be some clusters among the points of observed bill ratio. To find the source of this multimodal, you can change the conditional variable to facet the model checking on rows or columns using `mc_condition_on`.


```{r}
model_beta %>%
  mcplot(observation = penguins) +
  mc_distribution(ndraws = 1000) +
  mc_model_lineribbon() +
  mc_condition_on(x = vars(flipper_length_mm),
                  row = vars(sex))
```


```{r}
model_beta %>%
  mcplot(observation = penguins) +
  mc_distribution(ndraws = 1000) +
  mc_model_lineribbon() +
  mc_condition_on(x = vars(flipper_length_mm),
                  row = vars(island))
```


```{r}
model_beta %>%
  mcplot(observation = penguins) +
  mc_distribution(ndraws = 1000) +
  mc_model_lineribbon() +
  mc_condition_on(x = vars(flipper_length_mm),
                  row = vars(species))
```

### New model

When faceting on the species of penguins, you can see the points of observed bill ratio are clustered into three groups. This finding can inform an update on the model to include species as an independent variable.

```{r}
model_species <- brm(
  bf(bill_ratio ~ flipper_length_mm * species,
     phi ~ flipper_length_mm * species),
  family = Beta(),
  init = "0",
  data = penguins,
  prior = c(prior(normal(0, 0.5), class = "b"),
            prior(normal(0, 0.15), class = "b", dpar = "phi")),
  cores = 4,
  iter = 24000,
  warmup = 14000,
  
  file = "models/model_species.rds"
)
```

The result...

```{r}
model_species
```

You can check on this new model on the marginal effects of flipper length and species in one plot by using `mc_condition_on`.

```{r}
model_species %>%
  mcplot() +
  mc_distribution(ndraws = 1000) +
  mc_model_lineribbon() +
  mc_condition_on(x = vars(flipper_length_mm),
                  color = vars(species))
```

By this model checking, the new model is validated to capture the multimodal in the observed data. Then you can check more on the posterior distribution of the model conditioned on species using `vmc`.

```{r}
model_species %>%
  mcplot() +
  mc_model_slab(side = "left") +
  mc_obs_dots() +
  mc_condition_on(x = vars(species))
```

### Check on model assumptions

To check on some particular assumptions of the model, you can pick different mark types of the visual representation. For example, to check the calibration of the model, you can choose to use intervals to represent the model distribution.

```{r}
model_species %>%
  mcplot() +
  mc_model_interval() +
  mc_obs_interval() +
  mc_condition_on(x = vars(species)) +
  mc_layout_nested()
```

`vmc` also supports to check on other assumptions, like heteroskedasticity and the normality of residuals.

```{r}
model_species %>%
  mcplot() +
  mc_distribution(ndraws = 1) +
  mc_condition_on(x = vars(flipper_length_mm),
                  color = vars(species)) +
  mc_layout_encoding("residual") +
  mc_gglayer(geom_hline(yintercept = 0))
```


```{r}
model_species %>%
  mcplot() +
  mc_distribution(ndraws = 1) +
  mc_condition_on(color = vars(species)) +
  mc_layout_encoding("qq") +
  mc_gglayer(geom_abline())
```
